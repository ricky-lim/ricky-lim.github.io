title: Dynamic Yet Strong: Python Typing for Data Science
---
author: Ricky Lim
---
pub_date: 2025-07-14
---
body:

Python has been a language of choice for processing and data analysis pipeline.
Among its strength is its type system that is dynamic and yet strong.

We can think of a type system as a label on a data container.
It tells us what kind of data is inside so we can get the idea of what operations we can perform.
Just like a package labeled "Fragile" tells us that it should be handled with care, a data type label like int or str informs us which operations are valid.

In that context, consider the following function:

```python
def fahrenheit_to_celcius(f):
    return (f - 32) * 5 / 9
```

From a type perspective, what are the valid types for the input `f`, which is `float` in this case.

## Python is strongly typed

What does it mean? Python enforces **no implicit type coercion** to perform data operations.

For example:

```python
temp = 26.5
temp + "c"  # ❌ TypeError: unsupported operand type(s) for +: 'float' and 'str'
```

In contrast, weakly typed languages such as JavaScript, will coerce one type to another which might lead to subtle bugs.

```JavaScript
temp = 26.5
temp + "c" # '20.6c'
```

In data science, we're working with different data types - strings, integers, floats, pandas.Series, etc.
Strong typing protects us from such subtle bugs by refusing to mix incompatible types without being explicit.

## Python typing is also dynamic

Dynamically typed means that types are ***checked*** at **runtime**, when operations on objects are attempted.
With Dynamic typing property, Python supports Duck typing.
In practice, it means it doesn't matter what type an object is, only what an object can do.

It comes from the saying:

> If it looks like a duck, swims like a duck, and quacks like a duck — it’s probably a duck.

If I can invoke `person.quack()`, then `person` is probably a duck in this runtime context.

Duck typing offers flexibility and makes Python objects focus on get things done.

Dynamic typing makes Python easier to get started but allows unsupported operations that may cause errors at runtime.

As a comparison to the dynamic typing is a static typing adopted by C, Java, go, and other compiled languages, where you must declare types ahead of time.
The types are then enforced at compile time - the compiler checks that types match before the program even built and run.
This is more robust than duck typing, with the advantage of catching bugs earlier during build.

Unfortunately, these compile languages enforcing static typing provides additional cognitive overhead.
Furthermore although most type constraints are easy to express, many are complicated, hard to reason and read.

Since Python 3.15, Python supports gradual typing with Type Hints so we can gradually add types when it makes sense with a type checker.

## Usable Type Hints

Here are a few type hints that would be useful for your data science projects.

In type system, the more general the type is like `object` the narrower the interface.
For example, the `object` type supports fewer operations than `int`, `object` does not support `__mul__` for multiplication, whereas `int` does.

Following the Postel's Law:

> Be liberal in what you accept, be conservative in what you send,

When we annotate our function, use the abstract collection types for our input arguments, and concrete types for our output.

For example:

```
from typing import Sequence

def capitalize_names(names: Sequence[str]) -> list[str]:
    return [name.capitalize() for name in names]
```

Input: `Sequence[str]`

- Sequence is an abstract collection type, so it covers not only list but also tuple
- This allows the function to accept any sequence of strings
- More flexible for our users to call this function

Output: `list[str]`

- We return a concrete type: a new list of capitalized names
- This makes our users know exactly what they're getting, no guess needed.


### Optional

`Optional` is used when we want to use `None` as a default.

```python
from typing import Optional

def hello(name: Optional[str] = None) -> str:
    return f"hello {name}" if name else "hello world"
```

### Union

We use `Union` to allow multiple types as options, and requires at least two types.

```python
from typing import Union

def fahrenheit_to_celsius(f: Union[float, str]) -> float:
    ...

```

Also avoid using `Union` for redundant types.

```

# 🙅 This is redundant because float also covers operations performed by int
def fahrenheit_to_celsius(f: Union[int, float]) -> float:

# 🙆 float will also accept int values
def fahrenheit_to_celsius(f: float) -> float:
```

### Iterable

Iterable type is used to annotate anything you can loop over.
Example: `tuple`, `list`, `str`, `dict`.

Here is a practical example when we use `tuple` as type hints to represent a lab equipment (e.g from a database)

```python
# +------------+--------------+
# |equipment_id|equipment_name|
# +------------+--------------+
# |           1|    Microscope|
EquipmentRecord = tuple[int, str]

def get_equipment() -> tuple[EquipmentRecord]:
    ...
```

### Callable

Used to annotate function or callback parameters in higher-order functions.
Higher-order function is a function that takes another function as input or returns a function as output.
The signature of callable type:

```
Callable[[ParamType1, ParamType2], ReturnType]

# For no argument
Callable[[], ReturnType]

# With flexible signature
Callable[..., ReturnType]
```

For example:

We can generalize our `fahrenheit_to_celcius` into any temperature conversion with higher-order functions

```
from typing import Callable

def convert_temp(n: float, convert_fn: Callable[[float], float]) -> float:
    return convert_fn(n)

# Usage
def fahrenheit_to_celsius(f: float) -> float:
    return (f - 32) * 5 / 9

def celsius_to_fahrenheit(c: float) -> float:
    return c * 9 / 5 + 32

print(convert_temp(212, fahrenheit_to_celsius))
print(convert_temp(100, celsius_to_fahrenheit))
```

## Key take aways

- **Python is strongly typed**: No implicit type coercion prevents subtle bugs when mixing incompatible types
- **Dynamic typing enables duck typing**: Focus on what objects can do rather than what they are
- Gradually add types to duck typing with type hints
- Follow Postel's Law in type hints: be liberal in what you accept, be conservative in what you send

This allows our users to be flexible in using our functions and avoid extra burden on our user.
When our output contains multiple return types, it forces our users to check the type at runtime to know what to do with it - No Bueno.
