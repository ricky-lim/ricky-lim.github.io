title: Build CLI with Python
---
author: Ricky Lim
---
pub_date: 2025-10-26
---
main_image: image.png
---
body:

We're going to build a CLI tool like `grep` but in Python, so we named it `pygrep`.

## Start the project

```
uv init pyfreq
```

## Now we're creating a package

```
mkdir -p src/pyfreq/ # Create the package directory
touch src/pyfreq/__init__.py # this is to make it a package
```
## Create the CLI entry point

```
touch src/pyfreq/main.py
rm main.py # we don't need this file
```

As a starter, let's add a simple print to `main.py`

```python
def main():
    print("Hello pyfreq")
```

Then we will add the entry point in `pyproject.toml`

```toml
[project]
name = "pyfreq"
version = "0.1.0"
description = "Simple freq implementation in Python"
readme = "README.md"
requires-python = ">=3.12"
dependencies = []

[project.scripts]
pyfreq = "pyfreq.main:main"

[build-system]
requires = ["uv_build"]
build-backend = "uv_build"
```

## Let's test it

```
uv run pyfreq

# If we modify the print statement in cli.py, we can see the changes immediately
```

The `uv run` command will automatically create virtual environment and install the package in editable mode.
This is awesome for development!

## Implement CLI functionality

1\. Let's add the parser logic in `main.py`

```python
import argparse
import sys

from importlib.metadata import version
from pathlib import Path


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--version", "-v", action="version", version=f"{version('pyfreq')}"
    )
    parser.add_argument("word", type=str, help="Word to count")
    parser.add_argument("file_path", type=Path, help="Text file to search")

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)

    return parser.parse_args()
```

As a start, we implement a parser that shows the version of our CLI and accepts two arguments: `word` and `file`.

Now we can run: `uv run pyfreq` and it will print the help message.

So now we can continue implement the logic in our `main.py`.

Our cli should do the following steps:
- parse the args
- get the word and file path
- count the word in the file

Let's first refactor our `main` function to separate the logic

```python
def main() -> None:
    args = collect_args()

def collect_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--version", "-v", action="version", version=f"{version('pygrep')}"
    )
    parser.add_argument("query", type=str, help="Search query!")
    parser.add_argument("file_path", type=Path, help="Text file to search")

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)

    return parser.parse_args()

```

Then we can implement the logic to count the word and file path as our application config.
As these parameters are closely related, we can create a dataclass to hold these values.

```python
@dataclass
class Config:
    word: str
    file_path: Path

    @classmethod
    def build(cls, args: argparse.Namespace) -> "Config":
        if args.word is None:
            raise ValueError("Word is not provided")
        if args.file_path is None:
            raise ValueError("A file path is not provided")

        return cls(word=args.word, file_path=args.file_path)
```

Now our `main` function can be updated to:

```pythonpython
def main() -> None:
    args = collect_args()
    config = Config.build(args)
```

The next step is to implement the search logic.
As it is our domain logic, we can create a separate module for it, e.g. `lib.py`.

`touch src/pyfreq/lib.py` to create the file.

In `lib.py`, we can implement a simple count function:

```python
def count(word: str, content: str) -> dict[str, int]:
    raise NotImplementedError
```

The implementation will be at minimum, focusing only on the function signature.
Then we can create a test file to test this function.

First create a directory for tests. `mkdir tests`.
Then create the test file `touch tests/test_lib.py`.

Let's also add `pytest` as our development dependency.
`uv add --dev pytest`.

```python
from pyfreq.lib import count


def test_count_word():
    word = "python"
    content = """
Why Python developers don't get bitten?
Because python has no fangs, just indentation errors.
Life is short, use Python!
"""

    assert {"python": 1} == count(word, content)


def test_count_non_existent_word():
    word = "rust"
    content = """
Why Python developers don't get bitten?
Because python has no fangs, just indentation errors.
Life is short, use Python!
"""

    assert {"rust": 0} == count(word, content)
```

Run the test with `uv run -m pytest`.
This should fails as we haven't implemented the logic yet.
The failure should contain:

```sh
...
def count(word: str, content: str) -> dict:
>       raise NotImplementedError
E       NotImplementedError
...
```

Having tests first that fail is also assurance as tests that never fail are also dangerous.
Now let's implement the logic in `lib.py` to make the tests pass.

Let's implement the search logic in `lib.py`

```python
def count(word: str, content: str) -> dict[str, int]:
    result = {word: 0}

    for w in content.split():
        if w == word:
            result[word] += 1

    return result
```

Now run the test again with `uv run -m pytest`. This time it should pass.
Let's also optimize our logic to be more pythonic using dict comprehension.

```python
def count(word: str, content: str) -> dict[str, int]:
    word_count = sum(1 for w in content.split() if w == word)
    return {word: word_count}
```

Ok now we can go back to `main.py` to implement the remaining step to read the file and call the search function.

```python
def run(config: Config):
    with open(config.file_path, "r") as f:
        content = f.read()

    result = count(config.word, content)
    print(result)
```

Finally, we can update our `main` function to call the `run` function.

```python
def main() -> None:
    args = collect_args()
    config = Config.build(args)
    run(config)
```

So now our CLI is ready to use.
Let's create a sample text. `touch jokes.txt`

```
Why did the Python developer go broke?

Because he kept using "import this" instead of "import cash".

```

Now we can run our CLI to search for "cash" in `jokes.txt`

```sh
❯ uv run pyfreq cash jokes.txt
{'cash': 1}
```

Congratulations! You've built a simple CLI tool with Python.

Our structure looks like the following:

```sh
.
├── jokes.txt
├── pyproject.toml
├── README.md
├── src
│   └── pyfreq
│       ├── __init__.py
│       ├── lib.py
│       └── main.py
├── tests
│   └── test_lib.py
└── uv.lock
```
