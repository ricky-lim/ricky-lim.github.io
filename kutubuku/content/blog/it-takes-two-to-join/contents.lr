title: It Takes Two To Join
---
author: Ricky Lim
---
pub_date: 2025-06-21
---
body:

The world of SQL allows us to model the world of data as tables connecting one to another.
One of the common model is a star schema.
In this model, we have a table that contains many columns with IDs information.
Such IDs are used to connect us with different tables.
This where `join` becomes essential to connect these tables to extract information.

In this blog, we're going to explore different types of join with `pyspark`.
To join, we need two tables and here is the basic recipe for a join is:

```
[LEFT].join(
    [RIGHT],
    on=[PREDICATES],
    how=[METHOD]
)
```

Let's explore four different 'how' of joins using two tables: `lab_equipment`, `lab_protocol` .

## Tables

```bash
# Lab Equipment
+------------+--------------+
|equipment_id|equipment_name|
+------------+--------------+
|           1|    Microscope|
|           2|    Centrifuge|
|           3|       Pipette|
|           4|    Water bath|
|           5|  Spectrometer|
+------------+--------------+

# Lab Protocol
+-----------+-------------+------------+
|protocol_id|protocol_name|equipment_id|
+-----------+-------------+------------+
|        101|   Protocol A|           1|
|        101|   Protocol A|           2|
|        102|   Protocol B|           3|
|        102|   Protocol B|           6|
|        103|   Protocol C|           5|
|        104|   Protocol D|           1|
|        104|   Protocol D|           2|
|        104|   Protocol D|           5|
+-----------+-------------+------------+
```

## Inner Join

Returns rows where the join key exists in both tables.
Important to note that it may return duplicates in either table.
Also watch out if the id on the left table is not found on the right table it will be skipped.

```python
# Joining lab protocol with lab equipment based on equipment_id
(
    lab_protocol
        .join(lab_equipment, on=["equipment_id"], how="inner")
        .groupBy("protocol_name").agg(F.collect_list("equipment_name").alias("equipments"))
        .orderBy("protocol_name")
        .show(truncate=False)
)

+-------------+--------------------------------------+
|protocol_name|equipments                            |
+-------------+--------------------------------------+
|Protocol A   |[Microscope, Centrifuge]              |
|Protocol B   |[Pipette]                             |
|Protocol C   |[Spectrometer]                        |
|Protocol D   |[Microscope, Centrifuge, Spectrometer]|
+-------------+--------------------------------------+

```

With inner join,

1\. Multiple Matches return duplicates

- Microscope (id 1) and Centrifuge (id 2) appear twice as used in both protocol A and D.

2\. Non-Matches is skipped

- Water Bath (id 4) is skipped as no associated protocol
- Protocol B's equiment with id 6 is missing, only exact matches are included.

Depending on your use cases it may or may not be desirable.
If you want to ensure that the missing equipment is shown as NULL you need to use left join

```python
# Left join to also include a missing lab equipment
(
    lab_protocol
        .join(lab_equipment, on=["equipment_id"], how="left")
        # Replace `null` with a value MISSING
        .withColumn(
            "equipment",
            F.when(F.col("equipment_name").isNull(), F.lit("MISSING"))
              .otherwise(F.col("equipment_name"))
        )
        .groupBy("protocol_name")
        .agg(F.collect_list("equipment").alias("equipments"))
        .orderBy("protocol_name")
        .show(truncate=False)
)

+-------------+--------------------------------------+
|protocol_name|equipments                            |
+-------------+--------------------------------------+
|Protocol A   |[Microscope, Centrifuge]              |
|Protocol B   |[MISSING, Pipette]                    |
|Protocol C   |[Spectrometer]                        |
|Protocol D   |[Microscope, Spectrometer, Centrifuge]|
+-------------+--------------------------------------+

```

With left join, we are made aware that non-matching values are returned.
In our example, the non-matching equipment is returned as `MISSING`.

## Left Semi

A left semi join returns all rows from the left table where there is at least one matching row in the right table, based on the join condition.

This can be used for example, if we want to know which equipment that is at least being used once by a protocol.

```python
(
    lab_equipment
        .join(lab_protocol, on=["equipment_id"], how="left_semi")
        .show()
)

+------------+--------------+
|equipment_id|equipment_name|
+------------+--------------+
|           1|    Microscope|
|           2|    Centrifuge|
|           3|       Pipette|
|           5|  Spectrometer|
+------------+--------------+

```

## Left Anti

A left anti join returns only the rows from the left of the table that do **not** have a match in the right table, based on the join condition.

This type of join is useful to filter out the left table using right table.
For example we want to know which lab equipment that is not being used by our lab protocol.

```python
(
    lab_equipment
        .join(lab_protocol, on=["equipment_id"], how="left_anti")
        .show()
)

+------------+--------------+
|equipment_id|equipment_name|
+------------+--------------+
|           4|    Water bath|
+------------+--------------+
```

# Key Takeaways:

1\. Inner Join

- Only matching records between left and right tables are returned
- Non-matches are skipped: Equipment without protocols or protocols without equipment will not be shown
- Watch for duplicates: A protocol with multiple equipments will appear as duplicates
- Use case: Show a protocol with its equipment

2\. Left Semi Join

- Filter record with >= 1 match between left and right tables
- No duplicates
- Use case: List equipment used in at least one protocol

3\. Left Anti Join

- The opposite of left semi
- No duplicates
- Use case: Find unused equipment
