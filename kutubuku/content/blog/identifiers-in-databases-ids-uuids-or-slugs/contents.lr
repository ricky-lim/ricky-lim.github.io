title: Identifiers in Databases: IDs, UUIDs, or Slugs
---
author: Ricky Lim
---
pub_date: 2025-05-14
---
body:

Choosing the right identifier for database records is **essential** not just for **security** and **scalability**, but also for optimizing **data management** and **user experience**.
For data scientists, this choice can significantly impact query efficiency, data integrity and overall system performance.

In this blog, we're going to explore three common strategies for database identifiers and when to use each one.

## Auto-incremented IDs

These are sequential integers generated by the database such as in PostgresSQL.

### Pros

- Predictable as a reference. e.g: /blog/1
- Storage-efficient: minimal integer bytes
- Fast queries: optimized for indexing

### Cons

- Security risks: tells about record counts. For example: `/blog/1000` exposes 1000 entries.
- Distributed conflicts: challenging to sync across databases when scaling horizontally.

#### Example

```python
class Blog(Base):
    __tablename__ = 'blogs'

    id = Column(Integer, primary_key=True, autoincrement=True)
```

## UUIDs

Universally Unique Identifiers, are generated random strings e.g `blog/3a10a04e-5092-428f-a7eb-ef7df53057ec`.

### Pros

- Globally Unique: No sync issues across databases
- Secure: does not expose internal data

### Cons:

- Storage overhead: more bytes to store compared with integer bytes
- Index Fragmentation: Slower inserts and queries

#### Example

```python
class Blog(Base):
    __tablename__ = 'blogs'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
```

## Slugs

A URL-friendly labels. For example: `blog/identifiers-in-databases-ids-uuids-or-slugs`

### Pros

- User-friendly: human readable and shareable
- Search engine optimized: descriptive URLs boost search engine rankings

### Cons

- Ensuring uniqueness: requires adding random strings or numbers

#### Example

Using `slugify` function  from `python-slugify` library.

```python
class Blog(Base):
    __tablename__ = 'blogs'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String(250), nullable=False)

    # With unique is set to true, to ensure that slugs are indexed for fast lookups
    slug = Column(String(250), unique=True, nullable=False)

    @staticmethod
    def generate_slug(target, value, oldvalue, initiator):
        if value and (not target.slug or value != oldvalue):
            target.slug = slugify(value)

# To set a slugified version of the title whenever the title is set or changed
event.listen(Blog.title, 'set', Blog.generate_slug, retval=False)
```

## Key Takeaways

| Criteria     | Auto-ID         | UUID             | Slug        |
|--------------|-----------------|------------------|-------------|
| Security     | Low             | High             | Medium      |
| Uniqueness   | Single-database | Across-databases | Per-record  |
| Scalability  | Poor            | Excellent        | Good        |
| Use Case     | Internal APIs   | Distributed apps | Public URLs |

For simple internal APIs, using auto-incremented IDs is a good choice, as it provides efficient indexing with minimal overhead.
However, for scalable, secure, and descriptive public URLS when exposing your database records, combine **UUIDs** as primary keys with **slugs** derived from content like titles.
